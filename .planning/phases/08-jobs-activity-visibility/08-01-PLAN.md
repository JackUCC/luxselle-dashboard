---
phase: 08-jobs-activity-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/routes/jobs.test.ts
  - packages/server/src/routes/dashboard.test.ts
autonomous: true
requirements: [OPS-02, DATA-03]
gap_closure: true

must_haves:
  truths:
    - "POST /api/jobs/:id/retry returns 200 with updated job when job is failed and under retry limit"
    - "POST /api/jobs/:id/retry returns 400 when job status is not failed"
    - "POST /api/jobs/:id/retry returns 404 when job id does not exist"
    - "GET /api/dashboard/activity returns 200 with a data array"
    - "GET /api/dashboard/activity respects the ?limit param and returns events sorted by createdAt desc"
  artifacts:
    - path: "packages/server/src/routes/jobs.test.ts"
      provides: "Retry endpoint test coverage"
      contains: "POST /api/jobs/:id/retry"
    - path: "packages/server/src/routes/dashboard.test.ts"
      provides: "Activity endpoint test coverage"
      contains: "GET /api/dashboard/activity"
  key_links:
    - from: "jobs.test.ts"
      to: "packages/server/src/routes/jobs.ts"
      via: "supertest + vi.mock SystemJobRepo + vi.mock JobRunner"
      pattern: "mockRetry|mockGetById"
    - from: "dashboard.test.ts"
      to: "packages/server/src/routes/dashboard.ts"
      via: "supertest + vi.mock ActivityEventRepo"
      pattern: "mockActivityList"
---

<objective>
Add missing backend unit tests for two endpoints that are already implemented but untested: POST /api/jobs/:id/retry and GET /api/dashboard/activity.

Purpose: Both endpoints are used by the frontend wiring added in Plan 02. Tests must pass before execution is complete. Tests exercise the happy path, validation errors, and not-found cases using the established vi.hoisted + vi.mock + supertest pattern.
Output: Extended jobs.test.ts and dashboard.test.ts with passing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<interfaces>
<!-- Key interfaces the executor needs. Extracted from source. -->

From packages/server/src/routes/jobs.ts (POST /:id/retry):
```typescript
// Status check: only 'failed' or 'fail' jobs can be retried
// Retry limit check: job.retryCount >= (job.maxRetries || 3) returns 400
// On success: sets status='queued', increments retryCount, fires runJob async
// Returns: res.json({ data: updatedJob }) — 200
// Not found: 404 with { error: { code: 'NOT_FOUND', message: string } }
// Invalid state: 400 with { error: { code: 'BAD_REQUEST', message: string } }
```

From packages/server/src/routes/dashboard.ts (GET /activity):
```typescript
// Reads allEvents from activityRepo.list()
// Sorts by b.createdAt.localeCompare(a.createdAt) (desc)
// Slices to limit (default 20, from ?limit= query param)
// Returns: res.json({ data: ActivityEvent[] })
```

From packages/server/src/routes/jobs.test.ts (existing vi.hoisted pattern):
```typescript
const { mockList, mockGetById } = vi.hoisted(() => ({
  mockList: vi.fn(),
  mockGetById: vi.fn(),
}))
vi.mock('../repos/SystemJobRepo', () => ({
  SystemJobRepo: class {
    list = mockList
    getById = mockGetById
  },
}))
vi.mock('../services/JobRunner', () => ({ runJob: vi.fn() }))
// App setup: express() + app.use('/api/jobs', jobsRouter) + error handler
```

From packages/server/src/routes/dashboard.test.ts (existing mock pattern):
```typescript
// ActivityEventRepo is already mocked as: vi.mock('../repos/ActivityEventRepo', () => ({ ActivityEventRepo: class {} }))
// This stub needs to be upgraded to support a mockList function for activity tests
// Pattern: add mockActivityList to vi.hoisted block, give ActivityEventRepo a list method
const { mockActivityList } = vi.hoisted(() => ({ mockActivityList: vi.fn() }))
vi.mock('../repos/ActivityEventRepo', () => ({ ActivityEventRepo: class { list = mockActivityList } }))
```

ActivityEvent shape (packages/shared/src/schemas/activityEvent.ts):
```typescript
type ActivityEvent = {
  organisationId: string
  createdAt: string      // ISO string — sort key
  updatedAt: string
  actor: string
  eventType: string
  entityType: string
  entityId: string
  payload: Record<string, any>
}
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add POST /api/jobs/:id/retry tests to jobs.test.ts</name>
  <files>packages/server/src/routes/jobs.test.ts</files>
  <behavior>
    - Test: 200 + data with updated job when job exists, status is 'failed', retryCount is 0, maxRetries is 3
    - Test: 404 + error.code 'NOT_FOUND' when mockGetById returns null
    - Test: 400 + error.code 'BAD_REQUEST' when job.status is 'running' (not retryable)
    - Test: 400 + error.code 'BAD_REQUEST' when job.retryCount >= job.maxRetries (max retries exceeded)
  </behavior>
  <action>
    Extend packages/server/src/routes/jobs.test.ts. Do NOT rewrite the file — append a new describe block after the existing GET /api/jobs/:id describe.

    The existing vi.hoisted block already declares mockList and mockGetById. The existing vi.mock for SystemJobRepo gives the class a list and getById method. You need a set method too since the retry handler calls jobRepo.set(). Add mockSet to the vi.hoisted block and add set = mockSet to the SystemJobRepo mock class.

    The retry handler fires runJob in setImmediate — the existing vi.mock for JobRunner already stubs runJob as vi.fn(), so no async timing is needed in tests.

    Structure:
    ```typescript
    describe('POST /api/jobs/:id/retry', () => {
      beforeEach(() => { vi.clearAllMocks() })

      it('returns 200 with updated job data when job is retryable', async () => {
        const failedJob = { id: 'job-1', status: 'failed', retryCount: 0, maxRetries: 3, jobType: 'supplier_import' }
        const updatedJob = { ...failedJob, status: 'queued', retryCount: 1 }
        mockGetById.mockResolvedValue(failedJob)
        mockSet.mockResolvedValue(updatedJob)
        const res = await request(app).post('/api/jobs/job-1/retry')
        expect(res.status).toBe(200)
        expect(res.body.data).toBeDefined()
        expect(res.body.data.status).toBe('queued')
      })

      it('returns 404 when job does not exist', async () => {
        mockGetById.mockResolvedValue(null)
        const res = await request(app).post('/api/jobs/nonexistent/retry')
        expect(res.status).toBe(404)
        expect(res.body.error.code).toBe('NOT_FOUND')
      })

      it('returns 400 when job is not in a failed state', async () => {
        mockGetById.mockResolvedValue({ id: 'job-1', status: 'running', retryCount: 0, maxRetries: 3 })
        const res = await request(app).post('/api/jobs/job-1/retry')
        expect(res.status).toBe(400)
        expect(res.body.error.code).toBe('BAD_REQUEST')
      })

      it('returns 400 when max retries exceeded', async () => {
        mockGetById.mockResolvedValue({ id: 'job-1', status: 'failed', retryCount: 3, maxRetries: 3 })
        const res = await request(app).post('/api/jobs/job-1/retry')
        expect(res.status).toBe(400)
        expect(res.body.error.code).toBe('BAD_REQUEST')
      })
    })
    ```

    Ensure mockSet is added to the vi.hoisted() declaration at the top of the file alongside mockList and mockGetById, and that the SystemJobRepo mock class includes set = mockSet.
  </action>
  <verify>
    <automated>cd /Users/jackkelleher/luxselle-dashboard && npm test -- --reporter=verbose 2>&1 | grep -E "jobs\.test|POST /api/jobs|PASS|FAIL|Error" | head -30</automated>
  </verify>
  <done>All four retry test cases pass. npm test exits 0.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Add GET /api/dashboard/activity tests to dashboard.test.ts</name>
  <files>packages/server/src/routes/dashboard.test.ts</files>
  <behavior>
    - Test: 200 + res.body.data is an array when activityRepo.list() returns []
    - Test: returns events sorted by createdAt descending — newer event first when two events exist
    - Test: respects ?limit=1 param, returns only 1 event even when repo returns 2
  </behavior>
  <action>
    Extend packages/server/src/routes/dashboard.test.ts. Do NOT rewrite the file — append a new describe block after the existing GET /api/dashboard/profit-summary describe.

    The existing file already has `vi.mock('../repos/ActivityEventRepo', () => ({ ActivityEventRepo: class {} }))` at line 16 as a no-op stub. Replace this stub with a proper mock that exposes mockActivityList. The upgrade must use the same vi.hoisted pattern as the file's other mocks.

    IMPORTANT: dashboard.test.ts has two separate vi.hoisted() calls (lines 9-12 and 18-20). Add mockActivityList to the FIRST vi.hoisted() block alongside mockProductList and mockSourcingList, then update the ActivityEventRepo mock class to use list = mockActivityList.

    Structure of new describe block:
    ```typescript
    describe('GET /api/dashboard/activity', () => {
      beforeEach(() => {
        vi.clearAllMocks()
        mockActivityList.mockResolvedValue([])
      })

      it('returns 200 with data array', async () => {
        const res = await request(app).get('/api/dashboard/activity')
        expect(res.status).toBe(200)
        expect(Array.isArray(res.body.data)).toBe(true)
      })

      it('sorts events by createdAt descending', async () => {
        mockActivityList.mockResolvedValue([
          { createdAt: '2026-01-01T10:00:00Z', eventType: 'old', entityId: 'e1', entityType: 'supplier', actor: 'system', organisationId: 'default', updatedAt: '2026-01-01T10:00:00Z', payload: {} },
          { createdAt: '2026-01-02T10:00:00Z', eventType: 'new', entityId: 'e2', entityType: 'supplier', actor: 'system', organisationId: 'default', updatedAt: '2026-01-02T10:00:00Z', payload: {} },
        ])
        const res = await request(app).get('/api/dashboard/activity')
        expect(res.status).toBe(200)
        expect(res.body.data[0].eventType).toBe('new')
      })

      it('respects the limit query param', async () => {
        mockActivityList.mockResolvedValue([
          { createdAt: '2026-01-02T10:00:00Z', eventType: 'new', entityId: 'e1', entityType: 'supplier', actor: 'system', organisationId: 'default', updatedAt: '2026-01-02T10:00:00Z', payload: {} },
          { createdAt: '2026-01-01T10:00:00Z', eventType: 'old', entityId: 'e2', entityType: 'supplier', actor: 'system', organisationId: 'default', updatedAt: '2026-01-01T10:00:00Z', payload: {} },
        ])
        const res = await request(app).get('/api/dashboard/activity?limit=1')
        expect(res.status).toBe(200)
        expect(res.body.data).toHaveLength(1)
        expect(res.body.data[0].eventType).toBe('new')
      })
    })
    ```
  </action>
  <verify>
    <automated>cd /Users/jackkelleher/luxselle-dashboard && npm test -- --reporter=verbose 2>&1 | grep -E "dashboard\.test|GET /api/dashboard/activity|PASS|FAIL|Error" | head -30</automated>
  </verify>
  <done>All three activity test cases pass. npm test exits 0 with all existing tests still passing.</done>
</task>

</tasks>

<verification>
Run npm test from project root. All tests in packages/server/src/routes/jobs.test.ts and packages/server/src/routes/dashboard.test.ts must pass with no regressions to existing test cases.

```bash
cd /Users/jackkelleher/luxselle-dashboard && npm test 2>&1 | tail -20
```
</verification>

<success_criteria>
- POST /api/jobs/:id/retry: 4 test cases pass (200 success, 404 not-found, 400 wrong-state, 400 max-retries)
- GET /api/dashboard/activity: 3 test cases pass (200 shape, sort order, limit param)
- All pre-existing tests continue to pass
- npm test exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/08-jobs-activity-visibility/08-01-SUMMARY.md`
</output>
