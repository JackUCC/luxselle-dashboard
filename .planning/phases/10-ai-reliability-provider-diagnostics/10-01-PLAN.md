---
phase: 10-ai-reliability-provider-diagnostics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/schemas/pricing.ts
  - packages/server/src/services/search/SearchService.ts
  - packages/server/src/services/price-check/PriceCheckService.ts
  - packages/server/src/services/price-check/PriceCheckService.test.ts
  - packages/server/src/services/market-research/MarketResearchService.ts
  - packages/server/src/services/market-research/MarketResearchService.test.ts
  - packages/server/src/routes/pricing.test.ts
  - packages/server/src/server.ts
  - .env.example
autonomous: true
requirements:
  - STAB-01

must_haves:
  truths:
    - "When both AI providers fail, PriceCheckService returns dataSource: 'provider_unavailable' (not silent €0 labeled as ai_fallback)"
    - "When both AI providers fail, MarketResearchService.analyse() returns providerStatus: 'unavailable' in its result"
    - "POST /api/pricing/price-check returns 200 with { data: { dataSource: 'provider_unavailable' } } when all providers fail — not 503"
    - "GET /api/health?test_providers=1 returns providerTests object with per-provider ok/error result"
    - "All existing tests continue to pass after the schema enum extension"
  artifacts:
    - path: "packages/shared/src/schemas/pricing.ts"
      provides: "Extended PriceCheckResultSchema with dataSource enum including 'provider_unavailable'"
      contains: "provider_unavailable"
    - path: "packages/server/src/services/search/SearchService.ts"
      provides: "SearchResponse.providerError flag; searchMarketMultiExpanded sets it when all parallel calls fail"
      contains: "providerError"
    - path: "packages/server/src/services/price-check/PriceCheckService.ts"
      provides: "Early-exit path returning dataSource: 'provider_unavailable' when searchResponse.providerError"
      contains: "provider_unavailable"
    - path: "packages/server/src/services/market-research/MarketResearchService.ts"
      provides: "providerStatus field on MarketResearchResult interface; buildDegradedAnalysis sets providerStatus: 'unavailable'"
      contains: "providerStatus"
    - path: "packages/server/src/server.ts"
      provides: "Health endpoint extended with ?test_providers=1 mode"
      contains: "test_providers"
    - path: ".env.example"
      provides: "Comments clarifying which API key tier is required and how to test connectivity"
      contains: "test_providers=1"
  key_links:
    - from: "SearchService.searchMarket() catch block"
      to: "SearchResponse.providerError"
      via: "return { results: [], rawText: '', annotations: [], providerError: true }"
      pattern: "providerError.*true"
    - from: "SearchService.searchMarketMultiExpanded()"
      to: "merged SearchResponse.providerError"
      via: "allFailed = responses.every(r => r.providerError === true)"
      pattern: "every.*providerError"
    - from: "PriceCheckService.check() after searchMarketMultiExpanded"
      to: "early return with dataSource: 'provider_unavailable'"
      via: "if (searchResponse.providerError)"
      pattern: "searchResponse\\.providerError"
    - from: "MarketResearchService.analyse() after searchMarketMultiExpanded"
      to: "buildDegradedAnalysis with providerStatus: 'unavailable'"
      via: "if (searchResponse.providerError)"
      pattern: "searchResponse\\.providerError"
---

<objective>
Propagate AI provider failure signals through the backend stack so that failed searches produce
structured "provider unavailable" payloads rather than silent €0 results.

Purpose: Users currently see "No comparable listings found" when both AI providers fail — they cannot
distinguish a provider outage from a genuine lack of market data. This plan makes failures explicit.
Output: Extended shared schema, SearchService providerError flag, PriceCheckService early-exit path,
MarketResearchService providerStatus field, health endpoint test mode, and covering unit/integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-reliability-provider-diagnostics/10-CONTEXT.md
@.planning/phases/10-ai-reliability-provider-diagnostics/10-RESEARCH.md
</context>

<interfaces>
<!-- Key existing contracts the executor needs. Extracted from codebase. No exploration needed. -->

From packages/shared/src/schemas/pricing.ts (CURRENT — to be extended):
```typescript
export const PriceCheckResultSchema = z.object({
  averageSellingPriceEur: z.number(),
  comps: z.array(PriceCheckCompSchema),
  maxBuyEur: z.number(),
  maxBidEur: z.number(),
  dataSource: z.enum(['web_search', 'ai_fallback']),  // ADD 'provider_unavailable'
  researchedAt: z.string(),
  diagnostics: PriceCheckDiagnosticsSchema.optional(),
})
export type PriceCheckResult = z.infer<typeof PriceCheckResultSchema>
```

From packages/server/src/services/search/SearchService.ts (CURRENT — to be extended):
```typescript
export interface SearchResponse {
  results: SearchResult[]
  rawText: string
  annotations: Array<{ url: string; title: string }>
  // ADD: providerError?: boolean
}

// searchMarket() catch block (line ~242):
} catch (error) {
  logger.error('search_service_error', error)
  return { results: [], rawText: '', annotations: [] }   // ADD providerError: true
}

// searchMarketMultiExpanded() returns merged SearchResponse — ADD providerError propagation
// All sub-responses had providerError: true → merged result gets providerError: true
```

From packages/server/src/services/market-research/MarketResearchService.ts (CURRENT — to be extended):
```typescript
export interface MarketResearchResult {
  provider: string
  brand: string
  model: string
  estimatedMarketValueEur: number
  // ... (existing fields)
  confidence: number
  // ADD: providerStatus?: 'available' | 'unavailable'
}

// buildDegradedAnalysis() — currently returns confidence: 0.15 with no providerStatus
// ADD providerStatus: 'unavailable' to its return value

// analyse() — currently calls searchMarketMultiExpanded then checks hasSearchData
// ADD: check searchResponse.providerError BEFORE hasSearchData check
```

From packages/server/src/server.ts (CURRENT health endpoint):
```typescript
app.get('/api/health', (_req, res) => {
  const openaiConfigured = Boolean(env.OPENAI_API_KEY)
  const perplexityConfigured = Boolean(env.PERPLEXITY_API_KEY)
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    aiConfigured: openaiConfigured || perplexityConfigured,
    ai: {
      routingMode: env.AI_ROUTING_MODE,
      providers: { openai: openaiConfigured, perplexity: perplexityConfigured },
      searchModel: env.PERPLEXITY_SEARCH_MODEL,
    },
  })
})
// EXTEND: when req.query.test_providers === '1', add providerTests: { openai?: { ok, latencyMs?, error? }, perplexity?: {...} }
```

From packages/server/src/services/price-check/PriceCheckService.test.ts (mock setup):
```typescript
// Existing mocks available:
const { mockExpandQuery, mockSearchMarketMultiExpanded, mockEnrichComparables, mockGetRate, mockExtractStructuredJson } = vi.hoisted(...)
vi.mock('../search/SearchService', ...)
vi.mock('../ai/AiRouter', ...)
// To simulate provider failure: mockSearchMarketMultiExpanded.mockResolvedValue({ results: [], rawText: '', annotations: [], providerError: true })
```

From packages/server/src/routes/pricing.ts (price-check route):
```typescript
router.post('/price-check', async (req, res, next) => {
  const input = PriceCheckInputSchema.parse(req.body)
  const result = await priceCheckService.check(input)
  res.json({ data: result })
  // NOTE: PriceCheckService.check() never throws — it always returns PriceCheckResult
  // So the isAiUnavailableError catch path below is for the old 503 pattern; keep it for edge cases
  // The new provider_unavailable dataSource flows as a normal 200 response
})
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Extend shared schema and SearchService providerError propagation</name>
  <files>
    packages/shared/src/schemas/pricing.ts
    packages/server/src/services/search/SearchService.ts
  </files>
  <behavior>
    - PriceCheckResultSchema.dataSource enum includes 'provider_unavailable' as third value
    - SearchResponse interface has optional providerError?: boolean field
    - searchMarket() catch block returns { results: [], rawText: '', annotations: [], providerError: true }
    - searchMarketMultiExpanded() propagates providerError: when ALL responses have providerError === true, merged result gets providerError: true; if ANY response succeeded (has real results), providerError is NOT set (partial success = usable data)
    - searchMarketMulti() same treatment as searchMarketMultiExpanded()
    - searchWeb() catch block also sets providerError: true (for consistency)
    - Existing values 'web_search' and 'ai_fallback' are NOT renamed or removed
  </behavior>
  <action>
    1. In packages/shared/src/schemas/pricing.ts, find PriceCheckResultSchema (line ~139) and change:
       `dataSource: z.enum(['web_search', 'ai_fallback'])` to
       `dataSource: z.enum(['web_search', 'ai_fallback', 'provider_unavailable'])`

    2. In packages/server/src/services/search/SearchService.ts:
       - Add `providerError?: boolean` to the SearchResponse interface (line ~24).
       - In the searchMarket() catch block (line ~242), change:
         `return { results: [], rawText: '', annotations: [] }`
         to:
         `return { results: [], rawText: '', annotations: [], providerError: true as const }`
       - In searchWeb() catch block (~line 424), same change.
       - In searchMarketMulti() after the `for (const response of responses)` loop, before the final return, add:
         `const allFailed = responses.every((r) => r.providerError === true)`
         and append `...(allFailed ? { providerError: true as const } : {})` to the returned object.
       - In searchMarketMultiExpanded() after the `for (const response of responses)` loop, before the final return, add the same allFailed check and spread into the returned object.

    Run `npm test` after — all existing tests must pass.
  </action>
  <verify>
    <automated>npm test -- --reporter=verbose --filter=SearchService</automated>
  </verify>
  <done>
    - `z.enum(['web_search', 'ai_fallback', 'provider_unavailable'])` exists in pricing.ts
    - SearchResponse interface has providerError?: boolean
    - searchMarket() catch returns providerError: true
    - searchMarketMultiExpanded() propagates providerError: true only when ALL sub-calls failed
    - npm test passes (no regressions)
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: PriceCheckService early-exit and MarketResearchService providerStatus; add tests</name>
  <files>
    packages/server/src/services/price-check/PriceCheckService.ts
    packages/server/src/services/price-check/PriceCheckService.test.ts
    packages/server/src/services/market-research/MarketResearchService.ts
    packages/server/src/services/market-research/MarketResearchService.test.ts
    packages/server/src/routes/pricing.test.ts
  </files>
  <behavior>
    PriceCheckService:
    - When searchResponse.providerError === true immediately after searchMarketMultiExpanded(), return early with dataSource: 'provider_unavailable', all prices = 0, empty comps[], skip all extraction (mockExtractStructuredJson must NOT be called)
    - When providerError is NOT set, existing behaviour unchanged

    MarketResearchService:
    - MarketResearchResult interface gains providerStatus?: 'available' | 'unavailable'
    - analyse() checks searchResponse.providerError after searchMarketMultiExpanded — if true, calls buildDegradedAnalysis() and the result gets providerStatus: 'unavailable'
    - When hasSearchData is false but providerError is NOT set (search ran, found nothing), buildDegradedAnalysis() still returns providerStatus: 'unavailable' (both cases = provider/data unavailable for the user)
    - When search succeeds and returns data, synthesizeFromSearch() returns providerStatus: 'available'
    - buildDegradedAnalysis() adds providerStatus: 'unavailable' to its return value

    Tests to add:
    - PriceCheckService.test.ts: 'returns provider_unavailable when all search providers fail' — mock searchMarketMultiExpanded to return { results: [], rawText: '', annotations: [], providerError: true }; assert dataSource === 'provider_unavailable', prices === 0, comps === [], mockExtractStructuredJson not called
    - MarketResearchService.test.ts: 'buildDegradedAnalysis returns providerStatus unavailable' — assert result.providerStatus === 'unavailable'
    - pricing.test.ts: 'returns 200 with provider_unavailable dataSource when service signals it' — mock priceCheckService.check to return { ..., dataSource: 'provider_unavailable' }; assert res.status === 200 and res.body.data.dataSource === 'provider_unavailable'
  </behavior>
  <action>
    PriceCheckService.ts:
    - After `let searchResponse = await this.searchService.searchMarketMultiExpanded(variants, { userLocation })` (line ~92), add:
      ```typescript
      if (searchResponse.providerError) {
        const maxBuyEur = 0
        const maxBidEur = 0
        return {
          averageSellingPriceEur: 0,
          comps: [],
          maxBuyEur,
          maxBidEur,
          dataSource: 'provider_unavailable' as const,
          researchedAt: new Date().toISOString(),
          diagnostics: this.buildDiagnostics(searchResponse, await this.searchService.expandQuery(query), 'no_search_data', {
            strategyUsed: effectiveStrategy === 'auto' ? 'strict' : effectiveStrategy,
            extractedCompCount: 0,
            validCompCount: 0,
            filteredOutCount: 0,
          }),
        }
      }
      ```
      Note: queryContext is computed earlier on line ~86 as `const queryContext = await this.searchService.expandQuery(...)`, so use `queryContext` directly (already in scope), not a second expandQuery call.

    - Update the `dataSource` local variable declaration (line ~82) to include the new value:
      `let dataSource: 'web_search' | 'ai_fallback' | 'provider_unavailable' = 'ai_fallback'`

    MarketResearchService.ts:
    - Add `providerStatus?: 'available' | 'unavailable'` to the MarketResearchResult interface.
    - In buildDegradedAnalysis(), add `providerStatus: 'unavailable' as const` to the returned object.
    - In analyse() after `const searchResponse = await this.searchService.searchMarketMultiExpanded(...)`, add:
      ```typescript
      if (searchResponse.providerError) {
        return this.buildDegradedAnalysis(input, 'AI search providers are currently unavailable.')
      }
      ```
      (The buildDegradedAnalysis result already has providerStatus: 'unavailable' after the above change.)
    - In synthesizeFromSearch(), add `providerStatus: 'available' as const` to the formatResult return — but since formatResult builds from parsed data, add it in formatResult()'s return object.

    PriceCheckService.test.ts — add the new test case described in behavior above.
    MarketResearchService.test.ts — add the new test case.
    pricing.test.ts — add the new route test.

    Run `npm test` — all tests must pass including new ones.
  </action>
  <verify>
    <automated>npm test -- --reporter=verbose --filter="PriceCheckService|MarketResearchService|pricing"</automated>
  </verify>
  <done>
    - PriceCheckService returns dataSource: 'provider_unavailable' when providerError is set
    - MarketResearchResult has providerStatus field; buildDegradedAnalysis sets it to 'unavailable'
    - Three new tests pass: PriceCheckService provider_unavailable, MarketResearchService providerStatus, pricing route 200 payload
    - npm test passes with no regressions
  </done>
</task>

<task type="auto">
  <name>Task 3: Health endpoint test_providers mode and .env.example setup docs</name>
  <files>
    packages/server/src/server.ts
    .env.example
  </files>
  <action>
    Part A — Extend /api/health with ?test_providers=1 mode.

    Change the handler from `async (_req, res)` to `async (req, res)` and implement:

    ```typescript
    app.get('/api/health', async (req, res) => {
      const openaiConfigured = Boolean(env.OPENAI_API_KEY)
      const perplexityConfigured = Boolean(env.PERPLEXITY_API_KEY)

      const baseResponse = {
        status: 'ok',
        timestamp: new Date().toISOString(),
        aiConfigured: openaiConfigured || perplexityConfigured,
        ai: {
          routingMode: env.AI_ROUTING_MODE,
          providers: { openai: openaiConfigured, perplexity: perplexityConfigured },
          searchModel: env.PERPLEXITY_SEARCH_MODEL,
        },
      }

      if (req.query['test_providers'] !== '1') {
        res.json(baseResponse)
        return
      }

      // Lightweight test: minimal prompt per configured provider
      const { getAiRouter } = await import('./services/ai/AiRouter')
      const router = getAiRouter()
      const testResults: Record<string, { ok: boolean; latencyMs?: number; error?: string }> = {}

      if (openaiConfigured) {
        const t = Date.now()
        try {
          await router.generateText({ userPrompt: 'ping', maxTokens: 5 })
          testResults['openai'] = { ok: true, latencyMs: Date.now() - t }
        } catch (e) {
          testResults['openai'] = { ok: false, error: e instanceof Error ? e.message : String(e) }
        }
      }

      if (perplexityConfigured) {
        const t = Date.now()
        try {
          await router.generateText({ userPrompt: 'ping', maxTokens: 5 })
          testResults['perplexity'] = { ok: true, latencyMs: Date.now() - t }
        } catch (e) {
          testResults['perplexity'] = { ok: false, error: e instanceof Error ? e.message : String(e) }
        }
      }

      res.json({ ...baseResponse, providerTests: testResults })
    })
    ```

    Note: AiRouter is already imported at the top of server.ts as `aiRouter` (the Express router from routes/ai).
    Import getAiRouter from the service layer inline (dynamic import inside the handler) to avoid circular deps,
    OR check if it is already importable at the top level. Check existing imports first:
    - `import { aiRouter } from './routes/ai'` — this is the Express router, not the AI service
    - Add `import { getAiRouter } from './services/ai/AiRouter'` at the top of server.ts alongside other imports (not dynamic, it is safe — already used in service layer which server.ts indirectly loads).

    Run `npm test` — existing server/health tests must pass.

    Part B — Update .env.example AI section with setup guidance.

    The current .env.example AI section already has basic comments. Extend it to clarify:
    1. Which Perplexity tier each model requires
    2. How to verify provider connectivity after setup

    Replace the existing `# ─── AI ───` block (lines ~13-20) with:

    ```
    # ─── AI ───
    # dynamic | openai | perplexity
    AI_ROUTING_MODE=dynamic
    # OpenAI: any paid plan works (gpt-4o-mini used for text generation)
    OPENAI_API_KEY=<your-openai-api-key>
    # Perplexity: any paid plan works with sonar; sonar-pro requires Premium tier
    PERPLEXITY_API_KEY=<your-perplexity-api-key>
    # sonar = standard tier (works on all paid plans); sonar-pro = premium (deeper search, costs more)
    # Use sonar unless you have a Perplexity Premium subscription
    PERPLEXITY_SEARCH_MODEL=sonar
    PERPLEXITY_EXTRACTION_MODEL=sonar
    # To verify provider connectivity after setting keys:
    #   curl http://localhost:3001/api/health?test_providers=1
    # Expected: { "providerTests": { "openai": { "ok": true }, "perplexity": { "ok": true } } }
    ```

    Read the full .env.example first to locate the exact block to replace. Only modify the AI section —
    leave all other sections untouched.
  </action>
  <verify>
    <automated>npm test</automated>
  </verify>
  <done>
    - GET /api/health (no query param) returns same shape as before — no regression
    - GET /api/health?test_providers=1 returns { ...baseResponse, providerTests: { openai?: {...}, perplexity?: {...} } }
    - .env.example AI section includes comments explaining Perplexity tier requirements (sonar vs sonar-pro)
    - .env.example AI section includes the curl test_providers=1 example command
    - npm test passes
  </done>
</task>

</tasks>

<verification>
Run the full test suite after all tasks complete:

```bash
npm test
```

All 197+ existing tests must pass plus the 3 new test cases added in Task 2.

Spot-check schema:
```bash
node -e "const { PriceCheckResultSchema } = require('./packages/shared/src/schemas/pricing'); console.log(PriceCheckResultSchema.shape.dataSource._def.values)"
# Should output: [ 'web_search', 'ai_fallback', 'provider_unavailable' ]
```
</verification>

<success_criteria>
1. PriceCheckResultSchema.dataSource accepts 'provider_unavailable' as a valid value
2. SearchService.searchMarket() returns providerError: true in its catch block
3. searchMarketMultiExpanded() sets providerError: true on merged result only when ALL parallel calls failed
4. PriceCheckService.check() returns dataSource: 'provider_unavailable' with all-zero prices when providerError is set
5. MarketResearchResult has providerStatus field; buildDegradedAnalysis() sets it to 'unavailable'
6. GET /api/health?test_providers=1 returns providerTests object
7. .env.example clarifies Perplexity tier requirements and includes test_providers=1 curl example
8. 3 new tests pass; 0 regressions (npm test green)
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-reliability-provider-diagnostics/10-01-SUMMARY.md`
</output>
