import { beforeEach, describe, expect, it, vi } from 'vitest'
import { z } from 'zod'

const responsesCreate = vi.fn()
const chatCreate = vi.fn()
const fetchMock = vi.fn()

vi.mock('../../config/env', () => ({
  env: {
    AI_ROUTING_MODE: 'dynamic',
    OPENAI_API_KEY: 'test-openai-key',
    PERPLEXITY_API_KEY: 'test-perplexity-key',
    PERPLEXITY_SEARCH_MODEL: 'sonar-pro',
    PERPLEXITY_EXTRACTION_MODEL: 'sonar-pro',
  },
}))

vi.mock('openai', () => ({
  default: class OpenAI {
    responses = { create: responsesCreate }
    chat = { completions: { create: chatCreate } }
  },
}))

describe('AiRouter', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    global.fetch = fetchMock as unknown as typeof fetch
  })

  it('selects providers by task (perplexity-first search, openai-first generation)', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: 'search content' } }],
        citations: ['https://designerexchange.ie/item/1'],
      }),
    } satisfies Partial<Response>)

    const webSearch = await router.webSearch({ query: 'chanel classic flap' })

    expect(fetchMock).toHaveBeenCalledTimes(1)
    expect(responsesCreate).not.toHaveBeenCalled()
    expect(webSearch.provider).toBe('perplexity')

    chatCreate.mockResolvedValueOnce({
      choices: [{ message: { content: 'generated by openai' } }],
    })

    const generation = await router.generateText({
      systemPrompt: 'Be concise',
      userPrompt: 'generate text',
    })

    expect(chatCreate).toHaveBeenCalledTimes(1)
    expect(generation.provider).toBe('openai')
    expect(generation.data).toBe('generated by openai')
  })

  it('retries transient failures then fails over to fallback provider', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    const rateLimitError = Object.assign(new Error('rate limited'), { status: 429 })
    chatCreate
      .mockRejectedValueOnce(rateLimitError)
      .mockRejectedValueOnce(rateLimitError)

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: 'generated by perplexity' } }],
      }),
    } satisfies Partial<Response>)

    const result = await router.generateText({
      systemPrompt: 'Be concise',
      userPrompt: 'generate text',
    })

    expect(chatCreate).toHaveBeenCalledTimes(2)
    expect(fetchMock).toHaveBeenCalledTimes(1)
    expect(result.provider).toBe('perplexity')
    expect(result.fallbackUsed).toBe(true)
    expect(result.data).toBe('generated by perplexity')
  })





  it('temporarily deprioritizes unhealthy provider for a task', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    fetchMock
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)

    responsesCreate.mockResolvedValue({
      output_text: 'fallback search',
      output: [
        {
          type: 'message',
          content: [
            {
              type: 'output_text',
              annotations: [
                { type: 'url_citation', url: 'https://designerexchange.ie/item/1', title: 'Designer Exchange' },
              ],
            },
          ],
        },
      ],
    })

    await router.webSearch({ query: 'first call' })
    await router.webSearch({ query: 'second call' })
    await router.webSearch({ query: 'third call' })

    expect(fetchMock).toHaveBeenCalledTimes(3)

    await router.webSearch({ query: 'fourth call' })

    expect(fetchMock).toHaveBeenCalledTimes(3)
    expect(responsesCreate).toHaveBeenCalledTimes(4)
  })

  it('reports fallback provider usage and preserves provider-backed citations without fabrication', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    fetchMock
      .mockResolvedValueOnce({ ok: false, status: 429 } satisfies Partial<Response>)
      .mockResolvedValueOnce({ ok: false, status: 429 } satisfies Partial<Response>)

    responsesCreate.mockResolvedValueOnce({
      output_text: 'openai fallback content',
      output: [
        {
          type: 'message',
          content: [
            {
              type: 'output_text',
              annotations: [
                { type: 'url_citation', url: 'https://designerexchange.ie/item/100' },
                { type: 'url_citation', url: 'https://vestiairecollective.com/item/200' },
              ],
            },
          ],
        },
      ],
    })

    const result = await router.webSearch({ query: 'chanel medium flap caviar' })

    expect(result.provider).toBe('openai')
    expect(result.fallbackUsed).toBe(true)
    expect(result.data.annotations).toEqual([
      { url: 'https://designerexchange.ie/item/100', title: 'designerexchange.ie' },
      { url: 'https://vestiairecollective.com/item/200', title: 'vestiairecollective.com' },
    ])
  })

  it('calls openai extraction with json_object response_format', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    chatCreate.mockResolvedValueOnce({
      choices: [{ message: { content: '{"price":1500}' } }],
    })

    const result = await router.extractStructuredJson({
      systemPrompt: 'Return ONLY valid JSON.',
      userPrompt: 'extract price',
    })

    expect(result.provider).toBe('openai')
    expect(result.data).toEqual({ price: 1500 })
    expect(chatCreate.mock.calls[0][0]).toHaveProperty('response_format', { type: 'json_object' })
  })

  it('calls perplexity extraction without response_format when openai fails', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    chatCreate.mockRejectedValueOnce(Object.assign(new Error('openai down'), { status: 500 }))

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: '{"items":[{"name":"test"}]}' } }],
      }),
    } satisfies Partial<Response>)

    const result = await router.extractStructuredJson({
      systemPrompt: 'Return ONLY valid JSON.',
      userPrompt: 'extract items',
    })

    expect(result.provider).toBe('perplexity')
    expect(result.fallbackUsed).toBe(true)
    expect(result.data).toEqual({ items: [{ name: 'test' }] })

    const fetchCallBody = JSON.parse(fetchMock.mock.calls[0][1].body as string)
    expect(fetchCallBody).not.toHaveProperty('response_format')
  })

  it('validates extraction response against provided Zod schema', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    // OpenAI returns bad data (string instead of number)
    chatCreate.mockResolvedValueOnce({
      choices: [{ message: { content: '{"count": "not_a_number"}' } }],
    })

    // Perplexity fallback also returns bad data
    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: '{"count": "still_not_a_number"}' } }],
      }),
    } satisfies Partial<Response>)

    const schema = z.object({ count: z.number() })

    await expect(
      router.extractStructuredJson({
        systemPrompt: 'Return ONLY valid JSON.',
        userPrompt: 'count items',
        schema,
      }),
    ).rejects.toThrow(/schema/i)
  })

  it('extracts JSON from markdown-fenced response', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    chatCreate.mockResolvedValueOnce({
      choices: [{ message: { content: '```json\n{"value": 42}\n```' } }],
    })

    const result = await router.extractStructuredJson({
      systemPrompt: 'Return ONLY valid JSON.',
      userPrompt: 'extract value',
    })

    expect(result.data).toEqual({ value: 42 })
  })
})
