import { beforeEach, describe, expect, it, vi } from 'vitest'

const responsesCreate = vi.fn()
const chatCreate = vi.fn()
const fetchMock = vi.fn()

vi.mock('../../config/env', () => ({
  env: {
    AI_ROUTING_MODE: 'dynamic',
    OPENAI_API_KEY: 'test-openai-key',
    PERPLEXITY_API_KEY: 'test-perplexity-key',
    PERPLEXITY_SEARCH_MODEL: 'sonar-pro',
    PERPLEXITY_EXTRACTION_MODEL: 'sonar-pro',
  },
}))

vi.mock('openai', () => ({
  default: class OpenAI {
    responses = { create: responsesCreate }
    chat = { completions: { create: chatCreate } }
  },
}))

describe('AiRouter', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    global.fetch = fetchMock as unknown as typeof fetch
  })

  it('selects providers by task (perplexity-first search, openai-first generation)', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: 'search content' } }],
        citations: ['https://designerexchange.ie/item/1'],
      }),
    } satisfies Partial<Response>)

    const webSearch = await router.webSearch({ query: 'chanel classic flap' })

    expect(fetchMock).toHaveBeenCalledTimes(1)
    expect(responsesCreate).not.toHaveBeenCalled()
    expect(webSearch.provider).toBe('perplexity')

    chatCreate.mockResolvedValueOnce({
      choices: [{ message: { content: 'generated by openai' } }],
    })

    const generation = await router.generateText({
      systemPrompt: 'Be concise',
      userPrompt: 'generate text',
    })

    expect(chatCreate).toHaveBeenCalledTimes(1)
    expect(generation.provider).toBe('openai')
    expect(generation.data).toBe('generated by openai')
  })

  it('retries transient failures then fails over to fallback provider', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    const rateLimitError = Object.assign(new Error('rate limited'), { status: 429 })
    chatCreate
      .mockRejectedValueOnce(rateLimitError)
      .mockRejectedValueOnce(rateLimitError)

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        choices: [{ message: { content: 'generated by perplexity' } }],
      }),
    } satisfies Partial<Response>)

    const result = await router.generateText({
      systemPrompt: 'Be concise',
      userPrompt: 'generate text',
    })

    expect(chatCreate).toHaveBeenCalledTimes(2)
    expect(fetchMock).toHaveBeenCalledTimes(1)
    expect(result.provider).toBe('perplexity')
    expect(result.fallbackUsed).toBe(true)
    expect(result.data).toBe('generated by perplexity')
  })

  it('temporarily deprioritizes unhealthy provider for a task', async () => {
    const { AiRouter } = await import('./AiRouter')
    const router = new AiRouter()

    fetchMock
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)
      .mockResolvedValueOnce({ ok: false, status: 400 } satisfies Partial<Response>)

    responsesCreate.mockResolvedValue({
      output_text: 'fallback search',
      output: [
        {
          type: 'message',
          content: [
            {
              type: 'output_text',
              annotations: [
                { type: 'url_citation', url: 'https://designerexchange.ie/item/1', title: 'Designer Exchange' },
              ],
            },
          ],
        },
      ],
    })

    await router.webSearch({ query: 'first call' })
    await router.webSearch({ query: 'second call' })
    await router.webSearch({ query: 'third call' })

    expect(fetchMock).toHaveBeenCalledTimes(3)

    await router.webSearch({ query: 'fourth call' })

    expect(fetchMock).toHaveBeenCalledTimes(3)
    expect(responsesCreate).toHaveBeenCalledTimes(4)
  })
})
